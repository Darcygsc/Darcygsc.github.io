---
layout:     post
title:      "内存对齐"
subtitle:   ""
date:       2017-06-11
author:     "Darcy"
header-img: ""
tags:
- Pattern
image:
  feature: 
  teaser: work.jpg
  credit: Death to Stock Photo
  creditlink: ""
---

对齐：现代计算机中内存空间都是按照 `byte` 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放。

<!--more-->

## 对齐原因

- 平台移植：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的 `CPU` 在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐。

- 性能原因：有些平台每次读都是从偶地址开始，如果一个 `int` 型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32 `bit` ，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32 `bit` 数据。显然在读取效率上下降很多。

## 对齐规则

每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。我们可以通过预编译命令`#pragma pack(n)`，n = 1,2,4,8,16 来改变这一系数，其中的  `n`  就是你要指定的“对齐系数”。

- 数据成员对齐规则：结构 (`struct` ）（或联合(  `union`  ））的数据成员，第一个数据成员放在  `offset` 为0 的地方，以后每个数据成员的对齐按照  `#pragma pack` 指定的数值和这个数据成员自身长度中，比较小的那个进行。
- 结构（或联合）的整体对齐规则：在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照 `#pragma pack` 指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行。
- 当 `#pragma pack` 的 `n` 值等于或超过所有数据成员长度的时候，这个 `n` 值的大小将不产生任何效果。

## 概念

- 数据类型自身的对齐值：64位机器上  `char` 型数据自身对齐值为1字节，`short` 型数据为2字节，`int/float` 型为4字节，`double` 型为8字节，指针为8字节。
- 结构体或类的自身对齐值：其成员中自身对齐值最大的那个值。
- 指定对齐值：`#pragma pack (value)` 时的指定对齐值 `value`。
- 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值 = `min` {自身对齐值，当前指定的 `pack` 值}。

其中，有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐 `N` 表示”对齐在 `N` 上“，即该数据的“存放起始地址% `N` =0”。而数据结构中的数据变量都是按定义的先后顺序存放。

## 示例

```
char *p;  // 8个字节
char c;  // 1个字节
charpad[3];  //3个字节 
int a;  // 4个字节
```

`c` 的存储紧跟着 `p`。但 `a` 的4字节对齐要求造成一个缺口，所以这里造成了三个字节的浪费。

如果你想让这些变量占用较少的空间，你可以交换 `a`和 `c` 的位置：

```
char *p;  // 8个字节
int a;  // 4个字节
char c;  // 1个字节
```

### 结构体

```
struct A{
    char *p;
    char c;
    int a;
} ;
```

这样的话 `sizeof(A)`  为16个字节。那么如果我们交换 `c` 和 `a` 的位置:

```
struct B{
    char *p;  
    int a;  
    char c;  
};
```

你可能会认为 `sizeof(B)` 为13个字节，但是这样 `sizeof(B)` 还是为16个字节。因为 `struct` 是根据整体对齐系数来对齐。

整体对齐系数： `min((max(char *,int,char), 4)` = 4

成员总大小为 8 + 4 + 1 = 13

所以整体大小为：整体大小=（成员总大小）按（整体对齐系数） 圆整 = 13 按 4 圆整 = 16

### 结构体成员排序优化

```
struct C{
    char p;  // 1个字节
    int a;  // 4个字节
    char c;  // 1个字节
}
```

```
struct D{
    int a;  // 4个字节
    char c;  // 1个字节
    char p;  // 1个字节
}
```

上面结构成员都是一样，只是顺序不一样，但是大小前面一个是12个字节，后面一个是8个字节。

可以发现当结构体成员一个较大的数据类型（自身对齐值更大时）跟在较小的数据类型后面时，会造成结构体整体大小更大。我们可以通过自身对齐值递减的方式来排序成员，这样可以更好的节省内存占用。